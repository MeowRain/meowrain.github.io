# 算法代码
https://labuladong.gitee.io/algo/ds-class/shu-zu-lia-39fd9/er-fen-cha-b34e4/#%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2%E9%97%AE%E9%A2%98%E7%9A%84%E6%B3%9B%E5%8C%96

```cpp
#include <iostream>
#include <vector>
int left_bound(std::vector<int>& nums,int target){
    if(nums.size() == 0) return -1;
    int left = 0;
    int right = nums.size();
    while(left < right) {
        int mid = left + (right - left) / 2;
        if(nums[mid] == target) {
            //当找到target时候，收缩右边界
            right = mid;
        } else if (nums[mid] < target)
        {
            left = mid + 1;
        } else if(nums[mid] > target) {
            right = mid;
        }
        
    }
    return left;
}
int right_bound(std::vector<int>& nums,int target){
    if(nums.size() == 0) return -1;
    int left = 0;
    int right = nums.size();
    while(left < right) {
        int mid = left + (right - left)/2;
        if(nums[mid] == target){
            left = mid + 1;
        }else if(nums[mid] < target){
            left = mid + 1;
        } else if(nums[mid] > target) {
            right = mid;
        }
    }
    return right;
}
int main(void) {
    std::vector<int> arr = {1,2,3,3,3,4,5,6,7};
    int index = left_bound(arr,3);
    std::cout << "left_bound: " << index << std::endl;
    index = right_bound(arr,3);
    std::cout << "right_bound: " << index << std::endl;
    return 0;
}
```


![](https://static.meowrain.cn/i/2024/01/09/zn1m42-3.webp)

# 什么问题可以运用二分搜索算法技巧？

首先，你要从题目中抽象出一个自变量 x，一个关于 x 的函数 f(x)，以及一个目标值 target。

同时，x, f(x), target 还要满足以下条件：

1、f(x) 必须是在 x 上的单调函数（单调增单调减都可以）。

2、题目是让你计算满足约束条件 f(x) == target 时的 x 的值。

上述规则听起来有点抽象，来举个具体的例子：

给你一个升序排列的有序数组 nums 以及一个目标元素 target，请你计算 target 在数组中的索引位置，如果有多个目标元素，返回最小的索引。

这就是「搜索左侧边界」这个基本题型，解法代码之前都写了，但这里面 x, f(x), target 分别是什么呢？

我们可以把数组中元素的索引认为是自变量 x，函数关系 f(x) 就可以这样设定：

```cpp

// 函数 f(x) 是关于自变量 x 的单调递增函数
// 入参 nums 是不会改变的，所以可以忽略，不算自变量
int f(int x, int nums[]) {
    return nums[x];
}
```

其实这个函数 f 就是在访问数组 nums，因为题目给我们的数组 nums 是升序排列的，所以函数 f(x) 就是在 x 上单调递增的函数。

最后，题目让我们求什么来着？是不是让我们计算元素 target 的最左侧索引？

是不是就相当于在问我们「满足 f(x) == target 的 x 的最小值是多少」？

画个图，如下：
![](https://static.meowrain.cn/i/2024/01/09/10dxu1e-3.webp)

如果遇到一个算法问题，能够把它抽象成这幅图，就可以对它运用二分搜索算法。

---

# 例题


![](https://static.meowrain.cn/i/2024/01/09/10fpz1y-3.webp)


```cpp
class Solution {
public:

    int minEatingSpeed(vector<int>& piles, int h) {
        int left = 1;
        int right = 1000000000 + 1;
        while(left < right){
            int mid = left + (right - left) / 2;
            if(f(piles,mid) <= h){
                right = mid;
            }else {
                left = mid + 1;
            }
        }
        return left;
    }
    int f(vector<int>& piles,int x) {
        int hours = 0;
        for(int i = 0;i<piles.size();i++){
            hours+=piles[i]/x;
            if(piles[i] % x > 0){
                hours++;
            }
        }
        return hours;
    }
};

```

二分思路
这个题目的思路就是从1-maxvalue里面找最小速度
我们创建一个f函数，f(x)表示以x为速度的时候，用的时间，这样我们和警卫将要回来的时间进行对比，如果小，那么说明速度还能更慢，就继续往左边找
