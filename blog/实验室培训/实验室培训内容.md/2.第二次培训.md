# 一、使用计算机的一些注意事项

1. 尽量不要使用中文命名文件或文件夹，采用中文命名会产生一些意想不到的错误，因为有些编译器无法识别中文

2. 尽量分类整理好相应文件，比如创建一个CODE文件夹专门用于存放代码、创建一个envviroment文件夹用于存储环境配置等，这样可以方便于目录查找。

3. 浏览器建议使用edge、chrome或者firefox，搜索引擎尽量不要使用百度，百度内检索的内容普遍较差，从百度下载的软件很多带有捆绑软件。

4. 现阶段硬盘的处理速度等都已经有很大提升，所以无所谓需不需要分盘，但主要是文件需要分类清楚。

# 二、推荐一些好用的软件

1. Everything: 是一个强大的文件搜索工具，帮助快速定位计算机上的文件和文件夹。凭借其小的安装文件、干净而简单的用户界面、快速的文件索引和快速搜索能力，Everything使得找到您要寻找的内容变得轻松。无论需要进行故障诊断还是只是核实系统速度，此应用都会为您保驾护航。 可在voidtools官方网站下载，有安装版和便携版可供选择。

2. BandiZip: Bandizip是一款免费优秀的文件压缩/解压缩软件，界面简洁，功能明了，免费纯净无广告。它支持多国语言，解压后不会出现乱码，Bandizip拥有非常快速的压缩和解压缩的算法，适用于多核心压缩、快速拖拽、高速压缩等功能。

3. Snipaste: Snipaste 是一个简单但强大的截图工具，也可以让你将截图贴回到屏幕上

# 三、打算开始进行逐步考核

1. 会向实验室新生发放每日汇报表：  每日汇报表不要求真正意义上每天都需要填写，因为平时存在太忙太累导致忘记填写的现象，但是每日汇报表未填写的天数不能超过三天，超过三天的将会记录下来。

    每日汇报表着重要写：
    * 每日学习时长 
    * 每日所学（学习了些什么）
    * 遇到的问题
    * （实验室给分配工位的人员还需要标注自己当天是否来了实验室，在实验室待了多长时间）

每日汇报表每隔七天为一个轮回，七天之后会交给老师进行查看，另外每日汇报表内需要写好这周的目标。

例子如下：

| 姓名 | 10.14 |  10.15 |  10.16 |  10.17 |  10.18 | 10.19 |10.20 | 本周目标 |
| ---------- | ---------- | ---------- | ---------- | ---------- | ---------- | ---------- | ---------- | ---------- |
|xxx| 实验室工作时长：10点~18电 学习内容：C语言指针、结构体 遇到的问题： C语言二级指针不太理解如何表示 |  |  |  |  |  |  | 将C语言学习完成 |

2. C语言的学习预计在你们月考之后结束，C语言结束之后每人做一个小的demo，自己想做什么做什么，比如贪吃蛇、五子棋或者学生管理系统等，但需要使用到C语言，预计一周时间。demo在做完之后提交给本实验室。C语言学习完成之后将组织学习stm32

# 四、包管理器是什么

简单来说，“包管理器package manager”（或“软件包管理器”）是一种工具，它允许用户在操作系统上安装、删除、升级、配置和管理软件包。软件包管理器可以是像“软件中心”这样的图形化应用，也可以是像 apt-get 或 pacman 这样的命令行工具。

 <a href="https://linux.cn/article-12713-1.html">什么是包管理器</a>


## 4.1 windows下推荐使用的包管理器

### scoop包管理器

<a href="https://muxiner.github.io/using-scoop/">Windows 下包管理器 Scoop 的安装与使用_</a>

#### 总结

1. 安装scoop
2. 向scoop设置代理
3. 添加库 (scoop bucket add 库名)
4. 下载软件(scoop install 软件名)
5. 更新软件(scoop update 软件名)
6. 卸载软件(scoop uninstall 软件名)

# 五、git基本使用

## 5.1 什么是github

GitHub 是一个软件代码托管平台。

GitHub 是一个存放软件代码的网站。之所以要将代码放在网站上，可能有这么两个原因：



* 软件开源，即编写软件的代码对所有人公开，所有人可以在现有代码的基础上进行二次开发，减少不必要的重复劳动（ IT 行话简称不要重复「造轮子」）。一些非常常见的软件项目或者工具实际上刚开始都是在github上进行开源的，比如VUE、React等。

* 方便团队协作。这个过程有点像是我们把文档放在石墨或语雀这类支持团队协作的平台上，而 GitHub 上存放的是代码，参与编写软件的人可以通过 Git（版本控制工具）从 GitHub 拉取或往 GitHub 上传代码

对于初学者来讲，可能团队协作还为时太早，但是github上具有大量优良的开源项目或者思路，都是我们平时可以去学习乃至参考的，比如我们做一个项目没有思路，但我们可以去github上进行检索，从而找到其他人好的实现方式，去复刻这个项目。

github的作用不止于此，他还可以进行：

* 个人博客的挂载
* 将个人的笔记等数据保存在github上不易丢失，更换电脑后也可以随时找回

## 5.2 何为版本控制

什么是“版本控制”？我为什么要关心它呢？ 版本控制是一种记录一个或若干文件内容变化，以便将来查阅特定版本修订情况的系统。 

如果你是位图形或网页设计师，可能会需要保存某一幅图片或页面布局文件的所有修订版本（这或许是你非常渴望拥有的功能），采用版本控制系统（VCS）是个明智的选择。 有了它你就可以将选定的文件回溯到之前的状态，甚至将整个项目都回退到过去某个时间点的状态，你可以比较文件的变化细节，查出最后是谁修改了哪个地方，从而找出导致怪异问题出现的原因，又是谁在何时报告了某个功能缺陷等等。 使用版本控制系统通常还意味着，就算你乱来一气把整个项目中的文件改的改删的删，你也照样可以轻松恢复到原先的样子。 但额外增加的工作量却微乎其微。

## 5.3 什么是git

参考：<a href="https://liaoxuefeng.com/books/git/time-travel/reset/index.html">GIT教程</a>


### 5.3.1 四个工作区域
<div><img src="https://cdn.jsdelivr.net/gh/lcekold/blogimage@main/Network/gitquyuwenti.png"></div>


* Workspace： 工作区，就是你平时存放项目代码的地方

* Index / Stage： 暂存区，用于临时存放你的改动，事实上它只是一个文件，保存即将提交到文件列表信息

* Repository： 仓库区（或版本库），就是安全存放数据的位置，这里面有你提交到所有版本的数据。其中HEAD指向最新放入仓库的版本

* Remote： 远程仓库，托管代码的服务器，可以简单的认为是你项目组中的一台电脑用于远程数据交换

### 5.3.2 git工作流程

git的工作流程一般是这样的：

1. 在工作目录中添加、修改文件；

2. 将需要进行版本管理的文件放入暂存区域；

3. 将暂存区域的文件提交到git仓库。

因此，git管理的文件有四种状态：未跟踪(Untracked),已修改（modified）,已暂存（staged）,已提交(committed)

### 5.3.3 文件的四种状态

版本控制就是对文件的版本控制，要对文件进行修改、提交等操作，首先要知道文件当前在什么状态，不然可能会提交了现在还不想提交的文件，或者要提交的文件没提交上。
GIT不关心文件两个版本之间的具体差别，而是关心文件的整体是否有改变，若文件被改变，在添加提交时就生成文件新版本的快照，而判断文件整体是否改变的方法就是用
SHA-1算法计算文件的校验和。

<div><img src="https://cdn.jsdelivr.net/gh/lcekold/blogimage@main/Network/gitaddwtage.png"/></div>


* Untracked:   未跟踪, 此文件在文件夹中, 但并没有加入到git库, 不参与版本控制. 通过git add 状态变为Staged.

* Unmodify:   文件已经入库, 未修改, 即版本库中的文件快照内容与文件夹中完全一致. 这种类型的文件有两种去处, 如果它被修改, 而变为Modified.

    如果使用git rm移出版本库, 则成为Untracked文件

* Modified: 文件已修改, 仅仅是修改, 并没有进行其他的操作. 这个文件也有两个去处, 通过git add可进入暂存staged状态, 使用git checkout 则丢弃修改过,

        返回到unmodify状态, 这个git checkout即从库中取出文件, 覆盖当前修改

* Staged: 暂存状态. 执行git commit则将修改同步到库中, 这时库中的文件和本地文件又变为一致, 文件为Unmodify状态. 执行git reset HEAD filename取消暂存,

        文件状态为Modified


下面的图很好的解释了这四种状态的转变：

<div><img src="https://cdn.jsdelivr.net/gh/lcekold/blogimage@main/Network/jinxingdegitcaozuo.png"/></div>

新建文件--->Untracked

使用add命令将新建的文件加入到暂存区--->Staged

使用commit命令将暂存区的文件提交到本地仓库--->Unmodified

如果对Unmodified状态的文件进行修改---> modified

如果对Unmodified状态的文件进行remove操作--->Untracked

 

 ### 5.3.4 具体流程

 #### 1、工作区 -> 暂存区

使用 git add 命令将工作区中的修改添加到暂存区。

git add filename
#### 2、暂存区 -> 版本库

使用 git commit 命令将暂存区中的修改提交到版本库。

git commit -m "Commit message"
#### 3、版本库 -> 远程仓库

使用 git push 命令将本地版本库的提交推送到远程仓库。

git push origin branch-name
#### 4、远程仓库 -> 本地版本库

使用 git pull 或 git fetch 命令从远程仓库获取更新。

git pull origin branch-name

 或者

git fetch origin branch-name

git merge origin/branch-name

### 5.3.5 实际操作

假设你在工作目录中修改了 file.txt：

#### 1、工作区

修改 file.txt 并保存。

#### 2、暂存区

将修改添加到暂存区：

git add file.txt
#### 3、版本库

将暂存区的修改提交到本地版本库：

git commit -m "Update file.txt"
#### 4、远程仓库

将本地提交推送到远程仓库：

git push origin main


# 六、gcc如何使用

## 6.1 编译和链接是什么


### 编译
首先我们要明白两个概念，源程序和目标程序，源程序：是指用源语言写的，有待翻译的程序，
如我们自己写的一段c++代码，这段代码只有我们自己能看懂，计算机是不懂，计算机只能理解二进制。
目标程序：源程序通过翻译程序加工以后生成的机器语言程序。这是计算机可以理解的语言。把源程序转化为
目标程序的操作就叫做编译。

编译的过程相当于翻译，将一种语言翻译为另外一种机器可以听懂的语言

### 链接

C语言代码经过编译以后，会变成了二进制形式的目标文件（Object File）--- 对于 Visual C++，目标文件的后缀是.obj，对于 GCC，目标文件的后缀是.o。但此时的代码还不能运行起来。因为它还需要和系统提供的组件（比如标准库）结合起来，这些组件都是程序运行所必须的。例如我们要在屏幕中输出字符，这必须调用系统提供的库才能够实现。

这就是链接，经过链接才会生成 可执行程序 （如 win 平台上的exe）

<div><img src="https://cdn.jsdelivr.net/gh/lcekold/blogimage@main/Network/bianyideguocheng.png"/></div>

以上只针对C/C++来讲

对于C和C++，它们经过一次编译之后，可以由操作系统直接执行，所以它们是编译型语言。而Java不一样，它首先由编译器编译成.class文件，然后在通过JVM从class文件中读一行解释执行一行，所以它是解释型的语言。也正是由于java对于多种不同的操作系统有不同的JVM，所以实现了真正意义上的跨平台。

    注意 翻译程序有两种，一种为编译程序，另一种为解释程序

    编译程序，它将高级语言源程序一次性全部翻译成目标程序，每次执行程序时，只要执行目标程序。如 C（c++）程序的生成要经过： 编写源代码->编译->链接

    另一种是解释程序，它的执行过程是翻译一句执行一句，并且不会生成目标程序。如JavaScript、Python等。

    编译程序与解释程序最大的区别之一在于前者生成目标代码，而后者不生成；此外，前者产生的目标代码的执行速度比解释程序的执行速度要快。

## 6.2 什么是编译器、什么是链接器

### 编译器

编译器是将源代码转换为可执行文件的程序。在C++中，常用的编译器有GCC和Clang。编译器的主要工作是将源代码翻译成汇编代码，然后再将汇编代码转换成机器码。编译器还可以进行优化，使得程序的执行效率更高。
在使用编译器时，我们通常需要指定编译器的选项。常用的选项包括：
* c：只编译源代码，生成目标文件
* o：指定生成的目标文件名
* g：生成调试信息
* Wall：开启所有警告信息

例如，使用GCC编译源代码，并生成目标文件的命令如下：

    $ gcc -c main.cpp -o main.o

除了上述常用选项，编译器还提供了许多其他的选项，例如优化选项和预处理器选项。优化选项可以使程序的执行效率更高，而预处理器选项可以在编译之前进行宏替换和条件编译等操作。编译器的选项很多，需要根据实际情况选择合适的选项。

编译器的核心工作是将源代码转换为机器码，这个过程中错误和警告信息对于程序员来说非常重要。因此，我们应该开启编译器的警告信息以及调试信息，以便在开发过程中及时发现和解决问题。

### 链接器

链接器是将多个目标文件合并成一个可执行文件的程序。在C++中，常用的链接器有GCC和ld。链接器的主要工作是将程序中引用的函数和变量与定义的函数和变量进行匹配，最终生成可执行文件。
在使用链接器时，我们通常需要指定链接器的选项。常用的选项包括：
* o：指定生成的可执行文件名
* L：指定链接库的搜索路径
* l：指定链接库的名称

例如，使用GCC链接目标文件，并生成可执行文件的命令如下：

    $ gcc main.o -o main -L/usr/lib -lm

除了上述常用选项，链接器还提供了许多其他的选项，例如符号表选项和动态链接选项。符号表选项可以打印出程序中的符号表信息，而动态链接选项可以将链接库的加载推迟到运行时。链接器的选项也很多，需要根据实际情况选择合适的选项。

链接器的主要作用是将多个目标文件合并成一个可执行文件。在程序开发中，我们常常需要调用其他人编写的库函数。这时候，链接器会将程序中引用的函数与库函数进行匹配，从而生成可执行文件。如果链接器无法找到所需的库函数，编译过程就会失败。

### 编译器和链接器的工作流程

编译器和链接器是程序开发过程中不可或缺的工具，了解它们的工作流程有助于我们更好地使用它们。下面是编译器和链接器的工作流程：
1. 编译器将源代码转换为汇编代码。
2. 编译器将汇编代码转换为机器码，并生成目标文件。
3. 链接器将多个目标文件合并成一个可执行文件，并解决符号引用问题。

在这个过程中，编译器和链接器都需要使用选项来控制其行为。这些选项可以控制编译器和链接器的优化等级、调试信息、符号表和库文件搜索路径等等。

### 总结

编译器和链接器是C++编程中不可或缺的工具。编译器可以将源代码转换成机器码，而链接器可以将多个目标文件合并成一个可执行文件。在程序开发过程中，我们需要使用编译器和链接器来生成可执行文件。
除了编译器和链接器，还有很多其他的工具和技术可以帮助我们编写更高效、更可靠的程序。例如，调试器可以帮助我们查找程序中的错误；静态分析工具可以帮助我们检查代码中的潜在问题；性能分析工具可以帮助我们找到程序中的性能瓶颈。掌握这些工具和技术，可以提高我们的程序开发效率和代码质量。

## 6.3 C语言编译过程——预处理、编译汇编和链接详解

### 以hello world为例

hello world.c

```c
#include <stdio.h>
int main(){
    printf("hello,world!\n");
    return 0;
}
```

在linux下，使用 gcc 编译hello.c源文件，会在当前目录下默认生成 a.out 可执行文件，在终端输出hello，world！。

```c
[Panda@centos test]$ gcc hello.c
[Panda@centos test]$ ./a.out
[Panda@centos test]$ hello,world!
```

预编译器、汇编器as、链接器ld，实际上gcc 命令只是对这些不同程序的封装，根据不同的参数去调用不同的程序。
从 hello.c 到可执行文件的全过程，可分为4个步骤：

#### 1. 预处理

gcc -E hello.c -o hello.i 得到预处理文件，其中，-E 表示只进行预编译。

源文件在预编译阶段会被编译器生成.i文件，主要处理源代码文件中以“#”开头的预编译指令。如：宏定义展开，将被包含的文件插入到该编译指令的位置等。

#### 2. 编译

gcc -S hello.i -o hello.s 得到汇编文件，其中，-S 表示生成汇编文件。

编译就是把预处理完的文件，进行语法分析、词法分析、语义分析及优化后生成相应的汇编代码文件，这个过程是整个程序构建的核心过程，也是最复杂的部分。

#### 3. 汇编

as hello.s -o hello.o 或者 gcc -c hello.s -o hello.o，其中，-c 表示只编译不链接。

将汇编代码文件转变成机器可以执行的指令文件，即目标文件。也可以直接使用：gcc -c hello.c -o hello.o 经过预处理、编译、汇编直接输出目标文件。

为什么汇编器不直接生成可执行程序，而是一个目标文件呢？为什么要链接？这个我们后面会详细讨论。

#### 4. 链接
调用gcc hello.o -o hello

随着代码量的增多，所有代码若是都放在同一个文件里，那将是一场灾难。现代大型软件，动辄由成千上万的模块组成，每个模块相互依赖又相互独立。将这些模块组装起来的过程就是链接。

这些模块如何形成一个单一的程序呢？无非就是两种方式：1、模块间的函数调用；2、模块间的变量访问。函数访问必须知道函数地址，变量访问必须知道变量地址，所以终归到底就是一种方式，不同模块间符号的引用。

## 6.4 各文件后缀名描述


|后缀|	描述|	后缀|	描述|
|----|-----|-----|-----|
|.c|	C 源文件|	.s/.S|	汇编语言源文件|
|.C/.cc/.cxx/.cpp|	C++ 源文件|	.o/.obj|	目标文件|
|.h|	C/C++ 头文件|	.a/.lib|	静态库|
|.i/.ii|	经过预处理的 C/C++ 文件|	.so/.dll|	动态库|
|.exe| Windows下的可执行文件|  无 | 有时候为linux下的可执行文件，因为linux可自动识别文件类型|

## 6.5 什么是静态库，什么是动态库

### 什么是库

库是写好的现有的，成熟的，可以复用的代码。现实中每个程序都要依赖很多基础的底层库，不可能每个人的代码都从零开始，因此库的存在意义非同寻常。

本质上来说库是一种可执行代码的二进制形式，可以被操作系统载入内存执行。库有两种：静态库（.a、.lib）和动态库（.so、.dll）。

所谓静态、动态是指链接。回顾一下，将一个程序编译成可执行程序的步骤：

<div><img src="https://cdn.jsdelivr.net/gh/lcekold/blogimage@main/Network/jianyilianjie.png"/></div>

### 什么是静态库

一般扩展名为（.a或.lib）,这类的函数库通常扩展名为libxxx.a或xxx.lib 。

这类库在<b>编译的时候会直接整合到目标程序中</b>，所以利用静态函数库编译成的文件会比较大，这类函数库最大的优点就是编译成功的可执行文件可以独立运行，而不再需要向外部要求读取函数库的内容；但是从升级难易度来看明显没有优势，如果函数库更新，需要重新编译。

之所以成为【静态库】，是因为在链接阶段，会将汇编生成的目标文件.o与引用到的库一起链接打包到可执行文件中。因此对应的链接方式称为静态链接。

试想一下，静态库与汇编生成的目标文件一起链接为可执行文件，那么静态库必定跟.o文件格式相似。其实一个静态库可以简单看成是一组目标文件（.o/.obj文件）的集合，即很多目标文件经过压缩打包后形成的一个文件。静态库特点总结：

-  静态库对函数库的链接是放在编译时期完成的。

-  程序在运行时与函数库再无瓜葛，移植方便。

-  浪费空间和资源，因为所有相关的目标文件与牵涉到的函数库被链接合成一个可执行文件。

<div><img src="https://cdn.jsdelivr.net/gh/lcekold/blogimage@main/Network/jintaikudewenti.png"/></div>


### 什么是动态库
动态函数库的扩展名一般为（.so或.dll），这类函数库通常名为libxxx.so或xxx.dll 。

与静态函数库被整个捕捉到程序中不同，动态函数库在编译的时候，在程序里只有一个“指向”的位置而已，也就是说当可执行文件需要使用到函数库的机制时，程序才会去读取函数库来使用；也就是说可执行文件无法单独运行。这样从产品功能升级角度方便升级，只要替换对应动态库即可，不必重新编译整个可执行文件。

<b>共享库(动态库)的代码是在可执行程序运行时才载入内存的</b>，在编译过程中仅简单的引用，因此生成的可执行程序代码体积较小。

<div><img src="https://cdn.jsdelivr.net/gh/lcekold/blogimage@main/Network/dongtaikudeshiyong.png"/></div>



GCC命令使用：https://zhuanlan.zhihu.com/p/380180101?utm_psn=1828847142669778945

# 七、什么是环境变量

环境变量相对于给系统或用户应用程序设置的一些变量, 具体起什么作用这当然和具体的环境变量相关. 像path, 是告诉系统, 当要求系统运行一个程序而没有告诉它程序所在的完整路径时, 系统除了在当前目录下面寻找此程序外, 还应到那些目录下去找; 再象tc或bc++中, set include=path1;path2; 是告诉编译程序到哪里去找.h类型的文件; 当然不仅仅是指定什么路径, 还有其它的作用的, 像 set dircmd=/4 设置一个环境变量的作用是在使用dir命令是会把/4最为缺省的参数添加到你的dir命令之后, 就象你的每个命令都加了/4参数, 它实际上是给命令解释程序command设置的一个环境变量还是给dir这个内部命令设置的。

## 什么是环境变量？有什么用？

环境变量是包含关于系统及当前登录用户的环境信息的字符串,一些软件程序使用此信息确定在何处放置文件(如临时文件).

环境变量说白了就是指定一个软件的路径，比如说配置TomcatJdk等软件时就必须设置环境变量。方法如下：

点击我的电脑然后按右键——属性——高级——环境变量——新建——名称/路径。 

环境变量是包含诸如驱动器、路径或文件名之类的字符串。环境变量控制着多种程序的行为。例如，TEMP 环境变量指定程序放置临时文件的位置。

任何用户都可以添加、修改或删除用户的环境变量。但是，只有管理员才能添加、修改或删除系统环境变量。
 

 环境变量简单来说就是将某些数据，文件或文件夹设置为系统默认值，这样你调用的时候就不用给出完整路径和地址或进行设置，直接用名字就可以了

比如copy命令，它实际上在windows文件夹下，但我们在任何地方都可以调用，因为我们已将widows文件夹设置为环境变量了