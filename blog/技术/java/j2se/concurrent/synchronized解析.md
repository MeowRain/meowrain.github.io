## sychronized 关键字
引用 http://www.pianshen.com/article/13827882/
### java对象头
锁的实现机制与java对象头息息相关，锁的所有信息，都记录在java的对象头中。用2字（32位JVM中1字=32bit=4baye）存储对象头，如果是数组类型使用3字存储（还需存储数组长度）。对象头中记录了hash值、GC年龄、锁的状态、线程拥有者、类元数据的指针。

![](assets/markword.png)

### Syschronized作用：
Syschronized可以保证方法或者代码块在运行时同一时刻只有一个线程能进入临界区，同时保证共享变量对其他线程的可见性。

### JDK1.6 及之前 
**Synchronized是一个重量级锁**

Synchronized是通过对象内部的一个叫做监视器锁（monitor）来实现的。但是监视器锁本质又是依赖于底层的操作系统的Mutex Lock来实现的。而操作系统实现线程之间的切换这就需要从用户态转换到核心态，这个成本非常高，状态之间的转换需要相对比较长的时间，这就是为什么Synchronized效率低的原因。因此，这种依赖于操作系统Mutex Lock所实现的锁我们称之为“重量级锁”。JDK中对Synchronized做的种种优化，其核心都是为了减少这种重量级锁的使用。

### JDK1.6以后
**为了减少获得锁和释放锁所带来的性能消耗，提高性能，增加了从偏向锁到轻量级锁再到重量级锁的过度。**

锁的升级过程如下：锁的状态总共有四种：无锁状态、偏向锁、轻量级锁和重量级锁。随着锁的竞争，锁可以从偏向锁升级到轻量级锁，再升级的重量级锁（但是锁的升级是单向的，也就是说只能从低到高升级，不会出现锁的降级）
涉及jvm底层实现，需要注意：jdk1.6及以前使用重锁即获取监视器对象，以后多了锁升级和锁优化。

#### 锁优化
1. 自旋:该线程进行固定次数循环（自旋），尝试获取锁，失败后再挂起。
2. 适应性自旋：由虚拟机根据之前自旋获取锁的经验，动态判断是否自旋或者自旋次数。
3. 锁消除：为了保证数据的完整性，我们在进行操作时需要对这部分操作进行同步控制，但是在有些情况下，JVM检测到不可能存在共享数据竞争，这是JVM会对这些同步锁进行锁消除(StringBuffer、Vector、HashTable的加锁操作)
4. 如果虚拟机检测到有一系列连串的对同一个对象加锁和解锁操作，就会将其合并成一次范围更大的加锁和解锁操作。例如StringBuffer多次append操作。
#### 锁升级
**无状态->偏向锁->轻量锁->重量锁**
1. 轻量级锁：无竞争条件下 通过CAS消除同步互斥（多个线程交替执行同步块，没有竞争）。
2. 偏向锁：无竞争条件下 消除整个同步互斥，连CAS都不操作。（只有一个线程执行同步）。
3. 重量级锁：就是通常意义的锁了。

偏向锁则是在只有一个线程执行同步块时提高性能。而偏向锁则是在只有一个线程执行同步块时进一步提高性能。重量级锁用在同步块执行时间长且并发数高竞争频繁的情况。

JDk中采用轻量级锁和偏向锁等对Synchronized的优化，但是这两种锁也不是完全没缺点的，比如竞争比较激烈的时候，不但无法提升效率，反而会降低效率，因为多了一个锁升级的过程，这个时候就需要通过-XX:-UseBiasedLocking来禁用偏向锁。下面是这几种锁的对比：

![](assets/锁对比.png)
### 使用场景注意

在jdk1.6后，在并发控制逻辑比较简单时尽量使用sychronized关键字。需要重入锁读写锁等复杂场景还是用lock接口。