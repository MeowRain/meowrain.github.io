# 一、线程的三要素

## 1. 线程主体函数

线程实际上就是一个无限循环且不带返回值的C函数。目前，我们创建一个这样的线程，让开发板上面的LED灯以500ms的频率闪烁

```c
static void led1_thread_entry(void* parameter)
{
    while (1)
    {
        LED1_ON;
        rt_thread_delay(500);   /* 延时500个tick */     (1)

        LED1_OFF;
        rt_thread_delay(500);   /* 延时500个tick */

    }
}
```

* 代码清单:创建线程-3 (1)：线程里面的延时函数必须使用RT-Thread里面提供的延时函数，并不能使用我们 裸机编程中的那种延时。这两种的延时的区别是RT-Thread里面的延时是阻塞延时，即调用rt_thread_delay() 函数的时候，当前线程会被挂起，调度器会切换到其它就绪的线程，从而实现多线程。如果还是使用裸机编程中 的那种延时，那么整个线程就成为了一个死循环，如果恰好该线程的优先级是最高的，那么系统永远都是在这个 线程中运行，根本无法实现多线程。

目前我们只创建了一个线程，当线程进入延时的时候，因为没有另外就绪的用户线程，那么系统就会进入空闲线程， 空闲线程是RT-Thread系统自己启动的一个线程，优先级最低。当整个系统都没有就绪线程的时候，系统必须保证 有一个线程在运行，空闲线程就是为这个设计的。当用户线程延时到期，又会从空闲线程切换回用户线程。

## 2.定义线程栈

在RT-Thread系统中，每一个线程都是独立的，他们的运行环境都单独的保存在他们的栈空间当中。那么在定义好线程函数之 后，我们还要为线程定义一个栈，目前我们使用的是静态内存，所以线程栈是一个独立的全局变量，具体见 代码清单:创建线程-3。线 程的栈占用的是MCU内部的RAM，当线程越多的时候，需要使用的栈空间就越大，即需要使用的RAM空间就越多。一个MCU能够 支持多少线程，就得看你的RAM空间有多少。

```c
/* 定义线程控栈时要求RT_ALIGN_SIZE个字节对齐 */
ALIGN(RT_ALIGN_SIZE)
/* 定义线程栈 */
static rt_uint8_t rt_led1_thread_stack[1024];
```

在大多数系统中需要做栈空间地址对齐，例如在ARM体系结构中需要向4字节地址对齐。实现栈对齐的方法为，在定义栈之前，放置 一条ALIGN(RT_ALIGN_SIZE)语句，指定接下来定义的变量的地址对齐方式。其中ALIGN是在rtdef.h里面定义的一个宏，根据编 译器不一样，该宏的具体定义是不一样的，在ARM编译器中，该宏的定义具体见 代码清单:创建线程-5。ALIGN宏的形参RT_ALIGB_SIZE是 在rtconfig.h中的一个宏，目前定义为4。

```c
/* 只针对ARM 编译器，在其它编译器，该宏的实现会不一样 */
#define ALIGN(n) \__attribute__((aligned(n)))
```

## 3.定义线程控制块

定义好线程函数和线程栈之后，我们还需要为线程定义一个线程控制块，通常我们称这个线程控制块为线程的身 份证。在C代码上，线程控制块就是一个结构体，里面有非常多的成员，这些成员共同描述了线程的全部信息， 具体见 代码清单:创建线程-6。

```c
/* 定义线程控制块 */
static struct rt_thread led1_thread;
```

# 二、初始化线程

一个线程的三要素是线程主体函数，线程栈，线程控制块，那么怎么样把这三个要素联合在一起？RT-Thread里面有一个 叫线程初始化函数rt_thread_init()，它就是干这个活的。它将线程主体函数，线程栈（静态的）和线程控制块（静态的） 这三者联系在一起，让线程可以随时被系统启动，具体见 代码清单:创建线程-7。

```c
rt_thread_init(&led1_thread,                  /* 线程控制块 */     (1)
            "led1",                       /* 线程名字 */           (2)
            led1_thread_entry,            /* 线程入口函数 */       (3)
            RT_NULL,                      /* 线程入口函数参数 */    (4)
            &rt_led1_thread_stack[0],     /* 线程栈起始地址 */      (5)
            sizeof(rt_led1_thread_stack), /* 线程栈大小 */          (6)
            3,                            /* 线程的优先级 */        (7)
            20);                          /* 线程时间片 */          (8)
```

代码清单:创建线程-7 (1)：线程控制块指针，在使用静态内存的时候，需要给线程初始化函数 rt_thread_init()传递预先定义好的线程控制块的指针。在使用动态内存的时候，线程创建函数 rt_thread_create()会返回一个指针指向线程控制块，该线程控制块是rt_thread_create()函数 里面动态分配的一块内存。

代码清单:创建线程-7 (2)：线程名字，字符串形式，最大长度由rtconfig.h中定义的RT_NAME_MAX宏指定，多余部分会被自动截掉。

代码清单:创建线程-7 (3)：线程入口函数，即线程函数的名称。

代码清单:创建线程-7 (4)：线程入口函数形参，不用的时候配置为0即可。

代码清单:创建线程-7 (5)：线程栈起始地址，只有在使用静态内存的时候才需要提供，在使用动态内存的时候会根据提供的线程栈大小自动创建。

代码清单:创建线程-7 (6)：线程栈大小，单位为字节。

代码清单:创建线程-7 (7)：线程的优先级。优先级范围根据rtconfig.h中的宏RT_THREAD_PRIORITY_MAX 决定，最多支持256个优先级，目前配置为32。在RT-Thread中，数值越小优先级越高，0代表最高优先级。

代码清单:创建线程-7 (8)：线程的时间片大小。时间片的单位是操作系统的时钟节拍。当系统中存在相同优先级线程时，这 个参数指定线程一次调度能够运行的最大时间长度。这个时间片运行结束时，调度器自动选择下一个就绪态的同优先级线程进行运行。如 果同一个优先级下只有一个线程，那么时间片这个形参就不起作用。

# 三、线程启动函数

当线程初始化好后，是处于线程初始态（RT_THREAD_INIT），并不能够参与操作系统的调度，只有当线程进入 就绪态（RT_THREAD_READY）之后才能参与操作系统的调度。线程由初始态进入就绪态可由函数 rt_thread_startup()来实现，具体见 代码清单:创建线程-8。

```c
/* 启动线程，开启调度 */
rt_thread_startup(&led1_thread);
```

# 四、main.c文件全貌内容

现在我们把线程主体，线程栈，线程控制块这三部分代码统一放到main.c中，具体内容见 代码清单:创建线程-9。

```c
/*
*************************************************************************
*                             包含的头文件
*************************************************************************
*/
#include "board.h"
#include "rtthread.h"


/*
*************************************************************************
*                               变量
*************************************************************************
*/
/* 定义线程控制块 */
static struct rt_thread led1_thread;

/* 定义线程控栈时要求RT_ALIGN_SIZE个字节对齐 */
ALIGN(RT_ALIGN_SIZE)
/* 定义线程栈 */
static rt_uint8_t rt_led1_thread_stack[1024];
/*
*************************************************************************
*                             函数声明
*************************************************************************
*/
static void led1_thread_entry(void* parameter);


/*
*************************************************************************
*                             main 函数
*************************************************************************
*/
/**
* @brief  主函数
* @param  无
* @retval 无
*/
int main(void)
{
    /*
    * 开发板硬件初始化，RTT系统初始化已经在main函数之前完成，
    * 即在component.c文件中的rtthread_startup()函数中完成了。
    * 所以在main函数中，只需要创建线程和启动线程即可。
    */

    rt_thread_init(&led1_thread,                 /* 线程控制块 */
                "led1",                       /* 线程名字 */
                led1_thread_entry,            /* 线程入口函数 */
                RT_NULL,                      /* 线程入口函数参数 */
                &rt_led1_thread_stack[0],     /* 线程栈起始地址 */
                sizeof(rt_led1_thread_stack), /* 线程栈大小 */
                3,                            /* 线程的优先级 */
                20);                          /* 线程时间片 */
    rt_thread_startup(&led1_thread);             /* 启动线程，开启调度 */
}

/*
*************************************************************************
*                             线程定义
*************************************************************************
*/

static void led1_thread_entry(void* parameter)
{
    while (1)
    {
        LED1_ON;
        rt_thread_delay(500);   /* 延时500个tick */

        LED1_OFF;
        rt_thread_delay(500);   /* 延时500个tick */

    }
}

/********************************END OF FILE****************************/
```


